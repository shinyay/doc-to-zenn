## 第19章 トレイトを使う
この章での内容:
- トレイトを使えば、ジェネリック関数の呼び出しに関するコンパイラのエラーメッセージが読みやすくなること
- ジェネリックパラメータの制約が 1 つにまとまったり、複数のトレイトに分かれたりする理由
- ジェネリックパラメータに制約がないと、できることがどれほど少ないか
- トレイトに入れた関数のスコープ
- 複数のメソッドを含むトレイトを作る方法
- 複数のトレイトに渡すジェネリックパラメータを制約する方法
- トレイト継承を使う方法
- トレイトを使って外部型にメソッドを追加する方法
- 標準トレイトの `Display` と `Debug` を実装する方法
- 便利なジェネリックトレイトを宣言する方法
- 型指定を持たないトレイトをシンプルに使える関連型
- イテレータの実装
## 第20章 オブジェクト指向プログラミング
この章での内容:
- オブジェクトが割り当て解除されるとき実行されるメソッドとして、デストラクタを実装する方法
- 演算子の多重定義を (つまり Rust の演算子をユーザー定義型で使うためのメソッド群を) 実装する方法
- 失敗しない型変換と、危うい (失敗の可能性がある) 型変換を実装する方法
- なぜ Rust はデータ継承を使わないのか。その代わりに何を使っているのか
- 静的ディスパッチ、動的ディスパッチとは何か。どう実装され、いつ使われるのか
## 第21章 標準ライブラリのコレクション
この章での内容:
- Rust コードで各部の実行に費やされた時間を測定する方法
- どのコレクションを使うかを、性能を基準として選ぶ方法
- 各種の演算 (シーケンシャルスキャン、先頭や末尾で行う項目の挿入と削除、最大項目の削除、値によるサーチ、キーによるサーチ、順序付きサーチ) に、どのコレクションが最適なのか
- Rust 標準ライブラリのコレクションと、C++ 標準ライブラリのコレクションとの対応
## 第22章 所有権、移動、コピー
この章での内容:
- オブジェクトの確定的かつ暗黙的な破棄が、なぜ Rust の大きな利点なのか
- オブジェクトの所有権という考え方
- 代入に、共有とコピーと移動という、3 種類のセマンティクスがあること
- なぜ暗黙的な共有のセマンティクスが、ソフトウェアの正しさを損ねるのか
- なぜ移動のセマンティクスは、コピーのセマンティクスより高速かもしれないのか
- なぜ一部の型にだけコピーのセマンティクスが必要なのか
- なぜ一部の型について複製を禁止する必要があるのか
- ある型に、コピーのセマンティクスを使う必要があるとき、どのようにして指定するか
- ある型が複製可能であることを、どのようにして指定するか
## 第23章 借用とライフタイム
この章での内容:
- 参照に関する典型的なプログラミングエラー (移動後の使用、ドロップ後の使用、別名による変更後の使用) を防ぐために、Rust がどんな援助を提供しているのか
- 参照を**借用する**という Rust の概念
- オブジェクトや参照の**ライフタイム**という Rust の概念
- **ドロップ後の使用**エラーを、Rust の援助でどう防げるのか
- **別名による変更後の使用**エラーを、Rust と借用チェッカーの援助でどう防げるのか
- 参照を返す関数にライフタイム指定がなぜ必要なのか
- 関数にライフタイム指定を使う方法と、その意味
- 1 個の関数で複数のライフタイム指定を使う理由
## 第24章 さらにライフタイムについて
この章での内容:
- ライフタイムの推論が可能な、束縛のない関数やメソッドで、ライフタイム指定を省略する方法
- 構造体 / タプル構造体 / 列挙体が参照を含むと、なぜライフタイム指定が必要なのか
- 構造体 / タプル構造体 / 列挙体にライフタイムを指定する方法
