---
title: "100日後にRustをちょっと知ってる人になる: [Day 12]Rustの安全性"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: true
---
## Day 12 のテーマ

今日は言語仕様を学ぶのではなくて、O'Reilly から出版されている以下の Rust に関するレポートを読んでみようと思います。

- [O'Reilly Report - Why Rust?](https://learning.oreilly.com/library/view/why-rust/9781492048589/)
[![](https://storage.googleapis.com/zenn-user-upload/54fd34637737-20220903.png)](https://learning.oreilly.com/library/view/why-rust/9781492048589/)

ちなみに、レポート著者の Jim Blandy は、同じく O'Reilly から出版されている書籍の **[Programming Rust](https://learning.oreilly.com/library/view/programming-rust-2nd/9781492052586/)** の著者の方ですね。

## Why Rust by Jim Blandy

それではレポートを見ていきます。このレポートが公開されたのが、2015 年なのでもしかすると少し古い話も登場するかもしれませんが、それも意識しつつ読んでみます。

(１時間ほど読んでみた)

以下の内容について主にまとめられていました:

- Rust の安全性
- Rust の言語仕様

安全性について振れられている点を見てみます。

### Rust の安全性

Rust の言語としての目標:

- **メモリの安全性**
- **データ競合のない並行性**

メモリの安全性を満たすためのキーポイントは、**所有権**
所有権の効果:

- 各値の明確は有効期限を確立
- ガーベジコレクションを不要とする
- ソケットやファイルハンドルなどのリソース管理の健全化

Rust は、コンパイル時にメモリの安全性のチェックを行いますが、以下の観点のチェックで合格するか調べています:

- Null ポインターの逆参照はない
- ダングリングポインタはない
- バッファオーバーランはない

#### Null ポインターの逆参照

Null ポインタを逆参照しようとすることでのプログラムクラッシュは起こりません。

#### ダングリングポインタ

すべての値は必要な限り存続し、プログラムは、解放された後、ヒープ割り当て値を使用することはありません。

#### バッファオーバーラン

プログラムは、配列の末尾または先頭より前の要素にアクセスすることはありません。

バッファオーバーランが頻繁に発生するのはなぜでしょうか?
C　/ C++ では、実際には配列にインデックスを付けません。インデックス ポインターは、ポインターが指す配列またはオブジェクトの開始と終了に関する情報を保持しません。

Rust では、ポインタにインデックスを付けません。代わりに、どちらも明確な境界を持つ配列とスライスにインデックスを付けます。

## Day 12 のまとめ

Rust の安全性について特徴として上げている記事はいろろありますが、**Null ポインタの逆参照**、**ダングリングポイント**、**バッファオーバーラン**についてきちんとまとまっているものあまり目にしたことがありませんでした。このレポートは Rust の安全性について確認しるにはよい資料だと思います。