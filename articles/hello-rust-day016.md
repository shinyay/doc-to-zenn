---
title: "100日後にRustをちょっと知ってる人になる: [Day 16]演算子と記号"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: false
---
## Day 16 のテーマ

Rust の仕様をいろいろ見ながら学んでいますが、プログラムの記述に関して Rust の**シンボル**とか**記号**とか**キーワード**とかを覚えきれていなくて都度都度リファレンスを調べてしまったりしています。というわけで、今日は自分の頭の中の整理も兼ねてまとめておこうと思います。

## 演算子

|演算子|説明|例および備考|
|-----|---|--|
|!|マクロの展開|println!()|
|!|ビットの反転や論理反転|!0 => -1|
|!=|非等価比較|foo != bar|
|%|剰余演算|5 % 3|
|%=|剰余演算後に代入||
|&|借用|所有権を持たずに値を利用すること|
|&&|論理AND|foo && bar|
|*|掛け算|5 * 3|
|*|参照外し|参照から実データにアクセスする, let f = &mut foo, let bar = *f;|
|*=|掛け算後に代入||
|+|加算演算|5 + 3|
|+=|加算演算語に代入||
|-|減算演算||
|-=|減算演算後に代入||
|->|関数とクロージャの戻り値型|fn apply_twice(x: i32, f: fn(i32) -> i32) -> i32 { f(f(x)) }|
|..|未満指定|for x in 1 .. 101 // 1 から 100 まで|
|..|「残り全部」パターン束縛|let numbers = (2, 4, 8, 16, 32); match numbers { (first, .., last) => {}|
|...|値の範囲|1...5|
|/|割り算|5 / 3|
|/=|割り算後に代入||
|:|型制約|let i: i32|
|:|ループのラベル|'outer: loop { println!("外側のループ"); 'inner: loop { println!("内側のループ");|
|<<|左シフト||
|<<=|左シフト後に代入||
|=>|match のアーム記法|match x { 1 => println!("one")|
|>>|右シフト||
|>>|右シフト後に代入||
|@|パターンマッチした値を束縛| if let Some(i @ 0...5) = n { println!("{}", i); }|
|^|ビットXOR||
|^=|ビットXOR後に代入||
|\||OR|foo \| bar|
|\||クロージャ|let c = \|x: i32\| -> i32 { x + 1 };|
|\|\||論理OR|foo \|\| bar|
|?|エラー移譲|let f = File::open(filename)?;|

## Day 16 のまとめ
