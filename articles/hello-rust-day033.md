---
title: "100日後にRustをちょっと知ってる人になる: [Day 33]ジェネリクス"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: false
---
## Day 33 のテーマ

[Day 32](https://zenn.dev/shinyay/articles/hello-rust-day032] では**クロージャ**の使い方についていろいろと見てみました。
その中でクロージャを引数として受けとるような関数を考えた場合、次のようにします。

```rust
fn apply<F>(f: F) where F: Fn() {
    f();
}
```

つまり、クロージャが定義されたときに生成される無名の構造体 (`Fn`, `FnMut`, `FnOnce` のいずれかの**トレイト**を介して関数としての機能が実装されたもの) が型が未指定のため、関数を実行するために **ジェネリクス**が必要となります。

このように汎用的に型や関数を使えるようにするためにの機能が**ジェネリクス**です。

## ジェネリクス（総称型）

最近ではどのプログラム言語を使ってプログラムをしていても、**ジェネリクス**や**総称型**、また**ジェネリックプログラミング**といったキーワードを耳にすると思います。Wikipia ではどのように説明されているか見てみようと思います。

- [ジェネリックプログラミング](https://ja.wikipedia.org/wiki/%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)

> ジェネリック（総称あるいは汎用）プログラミングは、具体的なデータ型に直接依存しない、抽象的かつ汎用的なコード記述を可能にするコンピュータプログラミング手法である。

> ジェネリックプログラミングの特徴は、型を抽象化してコードの再利用性を向上させつつ、静的型付け言語の持つ型安全性を維持できることである。

つまり、型を抽象化して再利用性を高める仕組みといえます。
Rust や Java のようにコンパイル時に型が決定する**静的型付け言語**では、関数やメソッドを定義する際に受け取る引数データ型を予め決めて記述しておく必要があります。
そこで、型を抽象化した**任意の型**を用いることにより、引数の型の情報自体を引数として渡すなどの方法により、特定のデータ型に予め決定せずに処理内容を記述することができるようになります。
この仕組みのことを**ジェネリクス**といい、任意の型のことを**ジェネリック型**といいます。

## Rust でのジェネリクス

関数、構造体、列挙型でジェネリック型を使いには、それぞれの名前のうしろに**ダイアモンド演算子** `<>` を使い**ジェネリック型の名前**を指定します。
慣例的には、名前に `T` を使うことが多いです。

- 関数

```rust
fn foo<T>(a: T, b:T) -> T {
    a+b
}
```

- 構造体

```rust
struct Point<T> {
    x: T,
    y: T
}
```

## Day 33 のまとめ
