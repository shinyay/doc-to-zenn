---
title: "100日後にRustをちょっと知ってる人になる: [Day 40]"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: false
---
## Day 40 のテーマ

[Day 33](https://zenn.dev/shinyay/articles/hello-rust-day033) でジェネリクスに関する基本内容を確認しました。

以下のように、ダイヤモンド演算子 `<>` を使い、ジェネリック型の名前を指定することで定義する事ができることを確認していました。

```rust
struct Point<T> { x: T, y: T }

impl<T> Point<T> {
    fn do_something(self) -> (T, T) {
        (self.x, self.y)
    }
}
```

また、ジェネリック型の対して特定の処理 (**トレイト**) を実装しなければならないという事ができることを確認していました。その方式を **トレイト境界**と呼び、以下のように定義することを確認していました。

```rust
fn printer<T: Display>(t: T) {
    println!("{}", t);
}
```

上記の例では、`Displya` トレイトを実装している `T` 型をパラメータとして受け取る `printer` 関数が定義されています。つまり、`println!` マクロでパラメータを表示させようとしていますが、`T` が指定されたトレイトを実装していない場合はコンパイルエラーになってしまいます。

このように、ジェネリクスをつかってプログラムをコンパクトに書きつつも規定をかけていくことができることを確認できていました。

今回はジェネリクスを使って便利にすることができる、**Associated Type (関連型)**と**Phantom Type (幽霊型)** についてまとめたいと思います。
（しかし、ほんとに日本語訳として幽霊型でまかり通っているのかな？？？🤔）

## 関連型

まず最初に次のケースでのジェネリクスの利用について考えてみてください。

- あるトレイトがジェネリック型を用いて定義されている場合

この場合、このトレイトが実装されたものを使用する場合どうなるでしょうか？

実装例を見ながら考えてみましょう。

- 構造体

```rust
// 32 bit の整数型の要素を２つもつ構造体
struct Pont(i32, i32)
```

- トレイト

```rust
```

## Day 40 のまとめ

