---
title: "100日後にRustをちょっと知ってる人になる: [Day 40]"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: false
---
## Day 40 のテーマ

[Day 33](https://zenn.dev/shinyay/articles/hello-rust-day033) でジェネリクスに関する基本内容を確認しました。

以下のように、ダイヤモンド演算子 `<>` を使い、ジェネリック型の名前を指定することで定義する事ができることを確認していました。

```rust
struct Point<T> { x: T, y: T }

impl<T> Point<T> {
    fn do_something(self) -> (T, T) {
        (self.x, self.y)
    }
}
```

また、ジェネリック型の対して特定の処理 (**トレイト**) を実装しなければならないという事ができることを確認していました。その方式を **トレイト境界**と呼び、以下のように定義することを確認していました。

```rust
fn printer<T: Display>(t: T) {
    println!("{}", t);
}
```

上記の例では、`Displya` トレイトを実装している `T` 型をパラメータとして受け取る `printer` 関数が定義されています。つまり、`println!` マクロでパラメータを表示させようとしていますが、`T` が指定されたトレイトを実装していない場合はコンパイルエラーになってしまいます。

このように、ジェネリクスをつかってプログラムをコンパクトに書きつつも規定をかけていくことができることを確認できていました。

今回はジェネリクスを使って便利にすることができる、**Associated Type (関連型)**と**Phantom Type (幽霊型)** についてまとめたいと思います。
（しかし、ほんとに日本語訳として幽霊型でまかり通っているのかな？？？🤔）

## Day 40 のまとめ

