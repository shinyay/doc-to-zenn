---
title: "100日後にRustをちょっと知ってる人になる: [Day 50]Wasm Workers Server"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust,webassembly,wasm]
published: false
---
## Day 50 のテーマ

折返し地点の Day 50 になりました。思い返せば、Rust を勉強し始めた理由は **WebAssembly** を知ってる人になろうと思いはじめ、だったら Rust を知っておいた方が良さそうだ、という軽い気持ちでした。

今日はその動機のきっかけになった WebAssembly についてあらためて見てみようと思います。
というのも、ちょうど VMware がオープンソースのプロジェクトで **Wasm Worker Server** というものを今日発表したのです。その触ってみた内容をすこしまとめようと思います。

## Wasm Worker Server

まず最初に、この **Wasm Worker Server** が何かを説明します。
一言で言い表すならば、サーバーレスの仕組みを提供するプロジェクトです。ただし、サーバーレスとして動作させる対象のワークロードは、**ワーカー (Worker)** と呼ばれる軽量な構成で組み上げられたものになります。

そして、この**Wasm Worker Server**自体は自己完結型のバイナリとして実装されています。
これが単独で、ワーカーをホストしている WebAssembly ランタイムに対して HTTP リクエストをルーティングをします。

- [GitHub Repository](https://github.com/vmware-labs/wasm-workers-server)

### ワーカー (Worker)

継承な構成と紹介した**ワーカー (Worker)** ですが、これは**HTTP リクエストを受信して HTTP レスポンスを返すスクリプトまたは関数のこと**を指しています。
アプリケーション全体としては、このワーカーを複数組み合わせて開発することが可能です。それぞれのワーカーが特定のイベントをリッスンし、それに対する応答を提供します。アプリケーションを小さく分割した Microservices ならぬ **Nanoservices** と言えるようなもとも考えてもいいかもしれません。

このワーカーによる開発モデルはいくつかメリットが考えられます。

- 🧑‍💻 容易な開発: より小さくより集中できるように設計可能
- 🛠 容易なテスト: ワーカー毎に個別にテスト可能
- 🚀 容易なデプロイ: シンプルなコマンド 1 つでデプロイ可能


## Day 50 のまとめ
