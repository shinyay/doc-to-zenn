---
title: "100日後にRustをちょっと知ってる人になる: [Day 79]書籍: Rust プログラミング完全ガイド その3"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: false
---
## Day 79 のテーマ

![](https://storage.googleapis.com/zenn-user-upload/942b1e806720-20221205.png)

[Day 78](https://zenn.dev/shinyay/articles/hello-rust-day078) までに Rust の書籍の **[Rustプログラミング完全ガイド](https://book.impress.co.jp/books/1121101129)** の 1 章から 5 章までを読み終わりました。

- [第1章 Rustを始めよう](https://zenn.dev/shinyay/articles/hello-rust-day076#%E7%AC%AC1%E7%AB%A0-rust%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86)
- [第2章 数値演算などの基本を把握しよう](https://zenn.dev/shinyay/articles/hello-rust-day076#%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E3%81%AA%E3%81%A9%E3%81%AE%E5%9F%BA%E6%9C%AC%E3%82%92%E6%8A%8A%E6%8F%A1%E3%81%97%E3%82%88%E3%81%86)
- [第3章 オブジェクトに名前を付ける](https://zenn.dev/shinyay/articles/hello-rust-day076#%E7%AC%AC3%E7%AB%A0-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AB%E5%90%8D%E5%89%8D%E3%82%92%E4%BB%98%E3%81%91%E3%82%8B)
- [第4章 実行の流れを制御する](https://zenn.dev/shinyay/articles/hello-rust-day078#%E7%AC%AC4%E7%AB%A0-%E5%AE%9F%E8%A1%8C%E3%81%AE%E6%B5%81%E3%82%8C%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B)
- [第5章 データシーケンスを使う](https://zenn.dev/shinyay/articles/hello-rust-day078#%E7%AC%AC5%E7%AB%A0-%E5%AE%9F%E8%A1%8C%E3%81%AE%E6%B5%81%E3%82%8C%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B)
- 第6章 基本のデータ型を使う
- 第7章 列挙と照合
- 第8章 混成的なデータ構造を使う
- 第9章 関数を定義する
- 第10章 ジェネリックな関数や型を定義する
- 第11章 メモリを割り当てる
- 第12章 データの実装
- 第13章 クロージャを定義する
- 第14章 変更可能な文字列を使う
- 第15章 範囲とスライス
- 第16章 イテレータを使う
- 第17章 入出力とエラー処理
- 第18章 データのカプセル化［メソッドとモジュール］
- 第19章 トレイトを使う
- 第20章 オブジェクト指向プログラミング
- 第21章 標準ライブラリのコレクション
- 第22章 所有権、移動、コピー
- 第23章 借用とライフタイム
- 第24章 さらにライフタイムについて

今週中にこの書籍を読み終えようとおもっているのですが、今日はどこまで読み進められるでしょうか。というわけで、読んでいきたいと思います。

## 第6章 基本のデータ型を使う

この章での内容:

- 数値リテラルを 16 進 / 8 進 / 2 進の表記で書く方法
- 数値リテラルを読みやすくするためにアンダースコア (`_`) を使う方法
- 巨大な数や微細な数を指数表記でコンパクトに書く方法
- 基本となる 12 種類の整数型、2 種類の浮動小数点型の名前と範囲と用途
- 「具体的な型」または「未制約な型」の数値リテラルを指定する方法
- 数値を他の数値型に変換する方法
- その他のプリミティブ型 (真偽値、文字、空タプル)
- 型推論のしくみ
- 配列やベクターの型を表する方法
- コンパイル時の定数に名前を付ける方法
- コンパイラを使って式の型を調べる方法

### 型推論についてのメモ

Rust のコンパイラは賢く常に型を特定しようと働いてくれています。この型推論のアルゴリズムは次のような動き方になります。

- 型が**明示的**に指定されている変数の型は指定された型に決まる
- 変数や式の型が**未指定**で、ある特定の型でないと有効にならない式であったり宣言の場合、その**特定の型**に決まる
- ソースコードの解析終了時にコンパイラが **未制約な整数型**と判定していると、`i32` 型と定義される

### 整数型についてのメモ

|型|占有バイト数|最小値|最大値|
|--|----------|----|-----|
|i8|1|-128|127|
|i16|2|-32,768|32,767|
|i32|4|-2の31乗|2の31乗-1|
|i64|8|−2の63乗|2の63乗-1|
|i128|16|-2の127乗|2の127乗-1|
|isize|2 / 4 / 8|-2の15乗 / -2の31乗 / -2の63乗|2の15乗-1 / 2の31乗-1 / 2の63乗-1|
|u8|1|0|255|
|u16|2|0|65,355|
|u32|4|0|2の32乗-1|
|u64|8|0|2の64乗-1|
|u128|16|0|2の128乗-1|
|usize|2 / 4 / 8|0|2の16乗-1 / 2の32乗-1 / 2の64乗-1|

### 空タプルについてのメモ

`()` 型 (**空タプル**) の値は型名と同じく `()` です。`void` 型のようなもの。

## 第7章 列挙と照合

この章での内容:

- 変数定義で有限な選択肢の集合から値を選ぶ時に便利な列挙 (`enum`) の使い方
- `enum` を使って独自の共用体 (union) を実装する方法
- パターン照合の `match` 構造で `enum` をどう扱えるのか
- `match` 呼応像を使って、その他のデータ型 (整数、文字列、キャラクタなど) を扱う方法
- データフィールドを含む列挙を定義し、それらをリテラルと照合する方法
- `match` 文のパターンで変数を定義する方法
- `match` 式の使い方
- ブール型のガードを使って `match` 構造のパターン照合を汎用化する方法
- `if-let` と `while-let` の構造をどう使うのか

## enum と match についてのメモ

`enum` と `match` に登場する用語についての整理をしておきます。

### バリアント

```rust
enum City {Tokyo, SanFrancisco, London, Barcelona};
```

上記のように定義されている `enum` のそれぞれの値のことを **バリアント**と呼びます。
内部的にはそれぞれが `0u8`, `1u8`, `2u8`, `3u8` の値で表現されています。

### アーム

`match` 構造では条件ごとに実施する各ケースを並べます。そのそれぞれぞれを**アーム**と呼びます。

```rust
match city {
    City::Tokyo => print!("TK"),  // <- この各ケースが "アーム"
    City::SanFrancisco => print!("SF"),
    City::London => print!("LD"),
    City::Barcelona => print!("BA"),
}
```

## Day 79 のまとめ


