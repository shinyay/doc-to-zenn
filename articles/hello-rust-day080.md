---
title: "100日後にRustをちょっと知ってる人になる: [Day 80]書籍: Rust プログラミング完全ガイド その4"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [rust]
published: true
---
## Day 80 のテーマ

![](https://storage.googleapis.com/zenn-user-upload/942b1e806720-20221205.png)

[Day 79](https://zenn.dev/shinyay/articles/hello-rust-day079) までに Rust の書籍の **[Rustプログラミング完全ガイド](https://book.impress.co.jp/books/1121101129)** の 1 章から 7 章までを読み終わりました。

- [第1章 Rustを始めよう](https://zenn.dev/shinyay/articles/hello-rust-day076#%E7%AC%AC1%E7%AB%A0-rust%E3%82%92%E5%A7%8B%E3%82%81%E3%82%88%E3%81%86)
- [第2章 数値演算などの基本を把握しよう](https://zenn.dev/shinyay/articles/hello-rust-day076#%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E5%80%A4%E6%BC%94%E7%AE%97%E3%81%AA%E3%81%A9%E3%81%AE%E5%9F%BA%E6%9C%AC%E3%82%92%E6%8A%8A%E6%8F%A1%E3%81%97%E3%82%88%E3%81%86)
- [第3章 オブジェクトに名前を付ける](https://zenn.dev/shinyay/articles/hello-rust-day076#%E7%AC%AC3%E7%AB%A0-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AB%E5%90%8D%E5%89%8D%E3%82%92%E4%BB%98%E3%81%91%E3%82%8B)
- [第4章 実行の流れを制御する](https://zenn.dev/shinyay/articles/hello-rust-day078#%E7%AC%AC4%E7%AB%A0-%E5%AE%9F%E8%A1%8C%E3%81%AE%E6%B5%81%E3%82%8C%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B)
- [第5章 データシーケンスを使う](https://zenn.dev/shinyay/articles/hello-rust-day078#%E7%AC%AC5%E7%AB%A0-%E5%AE%9F%E8%A1%8C%E3%81%AE%E6%B5%81%E3%82%8C%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B)
- [第6章 基本のデータ型を使う](https://zenn.dev/shinyay/articles/hello-rust-day079#%E7%AC%AC6%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B%E3%82%92%E4%BD%BF%E3%81%86)
- [第7章 列挙と照合](https://zenn.dev/shinyay/articles/hello-rust-day079#%E7%AC%AC7%E7%AB%A0-%E5%88%97%E6%8C%99%E3%81%A8%E7%85%A7%E5%90%88)
- 第8章 混成的なデータ構造を使う
- 第9章 関数を定義する
- 第10章 ジェネリックな関数や型を定義する
- 第11章 メモリを割り当てる
- 第12章 データの実装
- 第13章 クロージャを定義する
- 第14章 変更可能な文字列を使う
- 第15章 範囲とスライス
- 第16章 イテレータを使う
- 第17章 入出力とエラー処理
- 第18章 データのカプセル化［メソッドとモジュール］
- 第19章 トレイトを使う
- 第20章 オブジェクト指向プログラミング
- 第21章 標準ライブラリのコレクション
- 第22章 所有権、移動、コピー
- 第23章 借用とライフタイム
- 第24章 さらにライフタイムについて

今週中にこの書籍を読み終えようとおもっているのですが、今日はどこまで読み進められるでしょうか。というわけで、読んでいきたいと思います。

## 第8章 混成的なデータ構造を使う

この章での内容:

- タプル
- 構造体
- タプル構造体

### タプルについてのメモ

タプルの定義の仕方は配列と似ています。

```rust
let array = ["first", "second", "third"];

println!("{}, {}, {}", array[0], array[1], array[2]);
```

```rust
let tuple = ("first", 2, 3.00);

println!("{}, {}, {}", tuple.0, tuple.1, tuple.2);
```

**配列は角括弧[]**で、**タプルは丸括弧()** という違いがあります。

### 構造体についてメモ

タプルも構造体も、複数の異なる型のオブジェクトを含んだ構造を定義するためのものです。

- **タプル**
  - 型に名前がない
  - 事前に宣言しない
  - フィールドに名前がない
- **構造体**
  - 型に名前がある
  - 事前に宣言しておく
  - フィールドに名前がある

```rust
struct SomeData {
    integer: i32,
    fractional: f32,
    character: char,
}

let data = SomeData {
    integer: 12,
    fractional: 34.56,
    character: 'a',
};

println!("{}, {}, {}", data.integer, data.fractional, data.character);
```

> ポイントは波括弧とセミコロンがないところ。

### タプル構造体についてメモ

タプルと構造体の中間のような構造

- **タプル構造体**
  - 型に名前がある
  - 事前に宣言しておく
  - フィールドに名前がない

```rust
struct SomeData (
    i32,
    f32,
    char,
);

let data = SomeData(
    12,
    34.56,
    'a',
);

println!("{}, {}, {}", data.0, data.1, data.2);
```

> ポイントは丸括弧とセミコロンがあるところ。

## 第9章 関数を定義する

この章での内容:

- 自作の関数を定義して呼び出す方法
- 同じ名前の関数は、いつ、どうすれば複数持てるのか
- 関数に引数を渡す方法（値渡しと参照渡し）
- 関数から単純な値や複合的な値を返す方法
- 関数を早期に終える方法
- オブジェクトへの参照、どう操作できるのか

### 値渡しと参照渡しについてメモ

Rust の関数を呼び出してパラメータ設定を行う時に特に何も気に留めなければ、**値渡し**になります。
値渡しの場合は、オブジェクトの**コピー**を渡しているので、元のデータへの変更は発生しません。

```rust
fn double(mut arr: [i32; 5]) {
    for i in 0..5 {
        arr[i] *= 2;
        println!("{}: {}", i, arr[i]);
    }
}

let mut arr = [1, 2, 3, 4, 5];

double(arr);
println!("{:?}", arr);
```

オブジェクトのコピーではなくて、データの**アドレス**を関数に引数として渡して、関数内の処理を元のデータに対しても影響させるのが**参照渡し**です。

```rust
fn double(arr: &mut [i32; 5]) {
    for i in 0..5 {
        (*arr)[i] *= 2;
        println!("{}: {}", i, arr[i]);
    }
}

let mut arr = [1, 2, 3, 4, 5];

double(&mut arr);
println!("{:?}", arr);
```

型指定の前に `&` を付けることで、その型を持つオブジェクトの**アドレスを指定**するという操作になります。一方で、関数の中ではアドレスを操作するのではなくて、**アドレスが参照しているオブジェクト**を操作します。そのようなオブジェクトにアクセスするには、`*`(アスタリスク)を変数名の前につけて呼び出します。

## Day 80 のまとめ

今日は 8 章の**タプル**や**構造体**などのデータ構造についてと、 9 章の　**値渡し**と**参照渡し** について読み進めてみました。

- **第8章 混成的なデータ構造を使う**
  - タプル
  - 構造体
  - タプル構造体
- **第9章 関数を定義する**
  - 自作の関数を定義して呼び出す方法
  - 同じ名前の関数は、いつ、どうすれば複数持てるのか
  - 関数に引数を渡す方法（値渡しと参照渡し）
  - 関数から単純な値や複合的な値を返す方法
  - 関数を早期に終える方法
  - オブジェクトへの参照、どう操作できるのか